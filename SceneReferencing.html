<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: Scene Referencing and DCSM</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">26.0.4</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Scene Referencing and DCSM </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>The concept</h1>
<p>There are two main roles in the DCSM/Ramses ecosystem:</p><ul>
<li>content provider (RamsesClient + DcsmProvider)<ul>
<li>create and offer content</li>
<li>modify content based on application logic</li>
</ul>
</li>
<li>content consumer (<a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> + <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a>)<ul>
<li>accept/assign content from providers</li>
<li>control content rendering state based on application logic</li>
</ul>
</li>
</ul>
<p>If one application implements both of these roles, it has full control over the rendered result. If the provider and consumer are two different applications then each takes care of its own part and thanks to DCSM and Ramses a large number of use cases can be achieved without any additional communication channel.</p>
<p>Now imagine a situation where there are 3 participants, each being a separate application:</p><ul>
<li>content provider A<ul>
<li>provides content not knowing where and how it ends up used (e.g. navigation map)</li>
</ul>
</li>
<li>content provider/consumer B<ul>
<li>accepts content from A, uses it inside its own content and offers the result as new content (e.g. navigation map extended with additional overlay elements)</li>
</ul>
</li>
<li>content consumer C<ul>
<li>accepts the single composited content from B and controls its rendering state</li>
</ul>
</li>
</ul>
<p>The participant B represents a new role which combines the two basic roles of provider and consumer. The important aspect to realize here is that C does not know anything about A and does not care about its content, it only takes content from B. Whether content from B nests other contents or not is irrelevant for C. Using this content nesting approach allows a nice and clearly defined separation of responsibilities between various components. In theory it can also scale to arbitrary number of nesting layers and arbitrary number of contents nested in each layer.</p>
<h1>The concept vs Ramses</h1>
<p>This concept works well with DCSM, the provider/consumer layer in the middle simply implements both <a class="el" href="classramses_1_1DcsmProvider.html" title="Class used to offer ramses content and meta infos to a consumer and synchronize actions between clien...">ramses::DcsmProvider</a> and <a class="el" href="classramses_1_1DcsmConsumer.html" title="Class representing DCSM consumer side. ">ramses::DcsmConsumer</a>. However applying this concept on Ramses level reveals a problem - the content to be nested coming from lower layer carries a very limited set of information - content ID, scene ID and maybe some DCSM metadata. Also there is typically just one <a class="el" href="classramses_1_1RamsesRenderer.html" title="RamsesRenderer is the main renderer component which provides API to configure and control the way con...">ramses::RamsesRenderer</a> for given content and it is owned by a consumer which in case of nesting is in the top layer, so it is inaccessible from any other layer.</p>
<h1>Scene Referencing</h1>
<p>To tackle the problem Ramses provides a scene referencing API which allows any scene to 'reference' another scene just by its scene ID, this establishes a master scene and referenced scene relationship. It is important to realize that this does NOT expose any of the referenced scene's Ramses objects (meshnodes, appearances, ...) to the master scene. Instead the API allows to change the referenced scenes rendering states similar to the <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a> API, i.e. rendering state, render order, data linking etc., see the <a class="el" href="classramses_1_1Scene.html" title="The Scene holds a scene graph. It is the essential class for distributing content to the ramses syste...">ramses::Scene</a> and <a class="el" href="classramses_1_1SceneReference.html" title="The SceneReference object refers to another ramses scene using its sceneId. ">ramses::SceneReference</a> API docs for details. Even though limited, this already gives a number of possibilities how to composite/nest scenes together.</p>
<p>Overview of the example above, now with scene referencing:</p><ul>
<li>content provider A<ul>
<li>creates and publishes sceneA (Ramses scene ID) offered in contentA (DCSM content ID) for categoryB (DCSM category ID)</li>
</ul>
</li>
<li>content provider/consumer B<ul>
<li>owns categoryB and accepts contentA with sceneA</li>
<li>creates and maintains its own sceneB</li>
<li>creates scene reference for sceneA in sceneB (sceneB becomes master of sceneA)</li>
<li>maintains sceneA's states using scene referencing API</li>
<li>publishes sceneB offered in contentB for categoryC</li>
</ul>
</li>
<li>content consumer C<ul>
<li>owns categoryC and accepts contentB with sceneB</li>
<li>maintains contentB's states using content control API</li>
</ul>
</li>
</ul>
<p>Consumer C knows nothing about provider A on application level which is one of the key goals of the initial concept. However down there, in consumer C's renderer, all the data is available to render sceneA as part of its master sceneB. <b>Scene referencing is essentially a remote control of renderering states limited to the scene being referenced.</b></p>
<p>In order to make all this technically possible there are several rules, guarantees and limitations:</p><ul>
<li>a scene can be referenced by one master only at a time</li>
<li>RamsesRenderer guarantees that referenced scene will never have higher rendering state than its master (higher state can however be requested from API and will be just kept back)</li>
<li>RamsesRenderer guarantees to show/hide master scene with all its references at once (assuming conditions for each scene involved to be ready/showable are met)</li>
<li>referenced scene inherits display mapping and display buffer assignment from its master</li>
<li>referenced scene's render order is relative to its master scene's render order</li>
</ul>
<p>Check out the scene referencing example in Ramses SDK to get the feeling of how to use the API for a basic use case.</p>
<h1>Scene Referencing events</h1>
<p>The mechanism of events dispatching is used in several Ramses APIs and it is not different with scene referencing. With scene referencing however we deal with two remote participants (referenced scene's provider and consumer with renderer), both contributing to the overall state. This makes it even more important to use the events carefully as means of synchronization and correct sequence of commands.</p>
<p>One event in particular can be helpful to achieve well defined behavior - a versioned flush applied event (<a class="el" href="classramses_1_1IClientEventHandler.html#af2b3c29f18d4d17cfb5754601b8b37c6" title="This method will be called after a flush with version tag (ramses::Scene::flush) has been applied and...">ramses::IClientEventHandler::sceneReferenceFlushed</a>). As stated above master scene has no access to referenced scene's internals, it can only request state changes for the scene as a whole on renderer's side. But Ramses scene can be flushed with a version tag, the said event is emitted whenever a referenced scene is flushed with version tag and that flush is fully applied to the scene on renderer's side. The version tag itself is a user defined value, so there can be an agreement how to interprete the value by the application logic (see <a class="el" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88" title="Commits all changes done to the scene since the last flush or since scene creation. This makes a new valid scene state available to all local and remote renderers. ">ramses::Scene::flush</a>).</p>
<h1>Understanding READY state</h1>
<p>The READY state is probably the most important state and should always be used as synchronization point whenever there is need to show a scene/content 'at once' (with minimal delay), Ramses guarantees to show any given READY scene in the very next frame after the show request. This is essential if a collection of scenes/contents need to appear together, which is probably the case whenever scene referencing is used. There are however different meanings of 'ready' and in the context of scene referencing good understanding might be necessary to properly implement some more advanced use cases.</p>
<p>There are two basic types of READY, one in the DCSM context (<a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">ramses::EDcsmState::Ready</a>) and the other in Ramses rendering context (<a class="el" href="namespaceramses.html#aee996152a40d451bbbefff0ae96c66d3ae7d31fc0602fb2ede144d18cdffd816b" title="Request content to be prepare to be shown at any time. ">ramses::RenderState::Ready</a>). Even though seemingly independent they need to be considered both together by any content consumer (including the middle layer consumer using scene referencing).</p><ul>
<li>DCSM READY (<a class="el" href="classramses_1_1DcsmProvider.html" title="Class used to offer ramses content and meta infos to a consumer and synchronize actions between clien...">ramses::DcsmProvider</a>) is just a signal between DCSM consumer/provider<ul>
<li>consumer requests READY, provider decides on its own when it is READY and sends signal back</li>
</ul>
</li>
<li>Ramses scene READY (<a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes. ">ramses::RendererSceneControl</a>) is more of a technical state<ul>
<li>a scene is READY when it is mapped to display, assigned to display buffer, its resources are uploaded and it is ready to be shown within a single frame</li>
</ul>
</li>
</ul>
<p>Then there is the <a class="el" href="classramses_1_1DcsmContentControl.html" title="DcsmContentControl provides way to interact with both Dcsm (as consumer) and renderer content control...">ramses::DcsmContentControl</a> which is already implemented in a way that combines the two for convenience:</p><ul>
<li>request READY -&gt; sends DCSM ready request and at the same time scene control ready request for scene associated with the content</li>
<li>reports READY &lt;- only when both DCSM content marked as ready by provider and the scene reported as ready from Ramses</li>
</ul>
<p>Typical example of a desired sequence of state requests/events would then look like this:</p>
<table class="doxtable">
<tr>
<th>Provider </th><th>Consumer/Provider (master scene) </th><th>Consumer with renderer </th></tr>
<tr>
<td></td><td>create <em>categoryB</em> </td><td>create <em>categoryC</em> </td></tr>
<tr>
<td>prepare <em>sceneA</em> and <em>contentA</em> </td><td>prepare <em>sceneB</em> and <em>contentB</em> </td><td>set up renderer </td></tr>
<tr>
<td>publish <em>sceneA</em> and offer <em>contentA</em> for <em>categoryB</em></td><td>publish <em>sceneB</em> and offer <em>contentB</em> for <em>categoryC</em> </td><td></td></tr>
<tr>
<td></td><td>assign <em>contentA</em> </td><td>assign <em>contentB</em> </td></tr>
<tr>
<td></td><td>create <em>sceneA</em> reference </td><td></td></tr>
<tr>
<td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td>request <em>contentB</em> <b>READY</b> </td></tr>
<tr>
<td></td><td>request <em>contentA</em> <b>READY</b> </td><td>(<em>sceneB</em> gets uploaded by Ramses internal logic) </td></tr>
<tr>
<td>update <em>sceneA</em> (optionally flush with version tag)</td><td></td><td></td></tr>
<tr>
<td>mark <em>contentA</em> <b>READY</b> </td><td></td><td></td></tr>
<tr>
<td></td><td>(optionally wait for version tag) </td><td></td></tr>
<tr>
<td></td><td>request <em>sceneA</em> reference <b>READY</b> </td><td></td></tr>
<tr>
<td></td><td>... </td><td>(<em>sceneA</em> gets uploaded by Ramses internal logic) </td></tr>
<tr>
<td></td><td>mark <em>contentB</em> <b>READY</b> </td><td></td></tr>
<tr>
<td></td><td>request <em>sceneA</em> reference <b>RENDERED</b> (<em>see note below</em>)</td><td></td></tr>
<tr>
<td></td><td></td><td></td></tr>
<tr>
<td></td><td></td><td>announce <em>contentB</em> will be <b>RENDERED</b> </td></tr>
<tr>
<td></td><td></td><td>set <em>contentB</em> to <b>RENDERED</b> </td></tr>
<tr>
<td></td><td></td><td>(both <em>sceneA</em> and <em>sceneB</em> are shown together) </td></tr>
</table>
<p>The important rule here is always prepare and make all the content you are nesting READY and only then report it as READY. Concretely in this example it means when contentB is requested to be READY via DCSM, make sure that contentB is DCSM READY and also all scenes nested into it were requested to be READY (both DCSM and as scene reference) and reported back as READY (again both DCSM and scene reference state), only then report the contentB as READY to its consumer.</p>
<p>Note regarding requesting the scene reference RENDERED: remember that a referenced scene's rendering state on renderer's side will be kept back to never be higher than master scene's state so it is safe to request RENDERED right away, it can even replace the READY request (state change events will anyway be reported one by one, so there will be event that scene reference is READY even when requested RENDERED right away). </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
