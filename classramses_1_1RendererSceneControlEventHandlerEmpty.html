<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RAMSES Documentation: ramses::RendererSceneControlEventHandlerEmpty Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ramses_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RAMSES Documentation
   &#160;<span id="projectnumber">27.0.101</span>
   </div>
   <div id="projectbrief">Information for RAMSES users and developers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceramses.html">ramses</a></li><li class="navelem"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html">RendererSceneControlEventHandlerEmpty</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classramses_1_1RendererSceneControlEventHandlerEmpty-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ramses::RendererSceneControlEventHandlerEmpty Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Convenience empty implementation of <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html" title="Provides an interface for handling the result of renderer scene control events. Implementation of thi...">IRendererSceneControlEventHandler</a> that can be used to derive from when only subset of event handling methods need to be implemented.  
 <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="IRendererSceneControlEventHandler_8h_source.html">IRendererSceneControlEventHandler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ramses::RendererSceneControlEventHandlerEmpty:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classramses_1_1RendererSceneControlEventHandlerEmpty__inherit__graph.svg" width="238" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ramses::RendererSceneControlEventHandlerEmpty:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classramses_1_1RendererSceneControlEventHandlerEmpty__coll__graph.svg" width="238" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89bbf910ecb31b0ec8ee9b4298c426c1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a89bbf910ecb31b0ec8ee9b4298c426c1">sceneStateChanged</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a> state) override</td></tr>
<tr class="memdesc:a89bbf910ecb31b0ec8ee9b4298c426c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when state of a scene changes.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a89bbf910ecb31b0ec8ee9b4298c426c1">More...</a><br /></td></tr>
<tr class="separator:a89bbf910ecb31b0ec8ee9b4298c426c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ade79e2fea4c8129ac9420e6fa7237"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a53ade79e2fea4c8129ac9420e6fa7237">offscreenBufferLinked</a> (<a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a> offscreenBufferId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success) override</td></tr>
<tr class="memdesc:a53ade79e2fea4c8129ac9420e6fa7237"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between offscreen buffer and scene's data slot is established.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a53ade79e2fea4c8129ac9420e6fa7237">More...</a><br /></td></tr>
<tr class="separator:a53ade79e2fea4c8129ac9420e6fa7237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b651548efc36f59d0276d673f3c38c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a55b651548efc36f59d0276d673f3c38c">dataLinked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> providerScene, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> providerId, <a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success) override</td></tr>
<tr class="memdesc:a55b651548efc36f59d0276d673f3c38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between a data provider and data consumer is established.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a55b651548efc36f59d0276d673f3c38c">More...</a><br /></td></tr>
<tr class="separator:a55b651548efc36f59d0276d673f3c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50349138c5a3a21b34230cbc1906a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a2b50349138c5a3a21b34230cbc1906a2">dataUnlinked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> consumerScene, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> consumerId, bool success) override</td></tr>
<tr class="memdesc:a2b50349138c5a3a21b34230cbc1906a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when the data link between a data provider and data consumer is destroyed.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a2b50349138c5a3a21b34230cbc1906a2">More...</a><br /></td></tr>
<tr class="separator:a2b50349138c5a3a21b34230cbc1906a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a9ba13148c9511965bc1df17d2574f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a81a9ba13148c9511965bc1df17d2574f">dataProviderCreated</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> dataProviderId) override</td></tr>
<tr class="memdesc:a81a9ba13148c9511965bc1df17d2574f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a data provider is created.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a81a9ba13148c9511965bc1df17d2574f">More...</a><br /></td></tr>
<tr class="separator:a81a9ba13148c9511965bc1df17d2574f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4eb3e937770dfe41c8726e25da5545"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#ace4eb3e937770dfe41c8726e25da5545">dataProviderDestroyed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a> dataProviderId) override</td></tr>
<tr class="memdesc:ace4eb3e937770dfe41c8726e25da5545"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a data provider is destroyed.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#ace4eb3e937770dfe41c8726e25da5545">More...</a><br /></td></tr>
<tr class="separator:ace4eb3e937770dfe41c8726e25da5545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db396b314db92c14266deee57164b31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6db396b314db92c14266deee57164b31">dataConsumerCreated</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> dataConsumerId) override</td></tr>
<tr class="memdesc:a6db396b314db92c14266deee57164b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a data consumer is created.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6db396b314db92c14266deee57164b31">More...</a><br /></td></tr>
<tr class="separator:a6db396b314db92c14266deee57164b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9704414b9cfa42ba1be50f76aaaa19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abe9704414b9cfa42ba1be50f76aaaa19">dataConsumerDestroyed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a> dataConsumerId) override</td></tr>
<tr class="memdesc:abe9704414b9cfa42ba1be50f76aaaa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a data consumer is destroyed.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abe9704414b9cfa42ba1be50f76aaaa19">More...</a><br /></td></tr>
<tr class="separator:abe9704414b9cfa42ba1be50f76aaaa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128450bdd7ef264424ef1f99036b6eb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a128450bdd7ef264424ef1f99036b6eb0">sceneFlushed</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, <a class="el" href="namespaceramses.html#ab7aa6bed4d47d2bd0967fc1a5ed6e95b">sceneVersionTag_t</a> sceneVersionTag) override</td></tr>
<tr class="memdesc:a128450bdd7ef264424ef1f99036b6eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called after a flush with version tag (<a class="el" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88" title="Commits all changes done to the scene since the last flush or since scene creation....">ramses::Scene::flush</a>) has been applied.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a128450bdd7ef264424ef1f99036b6eb0">More...</a><br /></td></tr>
<tr class="separator:a128450bdd7ef264424ef1f99036b6eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8295cfd70d6a8a7b66652cdcbd654d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6">sceneExpirationMonitoringEnabled</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId) override</td></tr>
<tr class="memdesc:af8295cfd70d6a8a7b66652cdcbd654d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a scene which was not previously monitored for expiration has requested expiration monitoring by sending a scene flush with valid expiration timestamp (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>) and that flush was applied on renderer side. From this point on, the scene will be monitored, can expire and recover (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a>) until monitoring disabled again (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d" title="This method will be called whenever a scene which was previously monitored for expiration has request...">sceneExpirationMonitoringDisabled</a>).  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6">More...</a><br /></td></tr>
<tr class="separator:af8295cfd70d6a8a7b66652cdcbd654d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9237861e7a2672972ce212f61e60c03d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d">sceneExpirationMonitoringDisabled</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId) override</td></tr>
<tr class="memdesc:a9237861e7a2672972ce212f61e60c03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called whenever a scene which was previously monitored for expiration has requested to stop being monitored by sending a scene flush with invalid expiration timestamp (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>) and that flush was applied on renderer side. From this point on, the scene will not be monitored anymore, regardless if it previously expired or not, i.e. there will be no expiration events (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a>) until monitoring enabled again (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6" title="This method will be called whenever a scene which was not previously monitored for expiration has req...">sceneExpirationMonitoringEnabled</a>).  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d">More...</a><br /></td></tr>
<tr class="separator:a9237861e7a2672972ce212f61e60c03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc3814bfdaaf45fed51abdb3669dfa1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1">sceneExpired</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId) override</td></tr>
<tr class="memdesc:abbc3814bfdaaf45fed51abdb3669dfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called if a scene which is enabled for expiration monitoring (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6" title="This method will be called whenever a scene which was not previously monitored for expiration has req...">sceneExpirationMonitoringEnabled</a>) is on renderer (not necessarily rendered) at a state that expired, i.e. current time is after the expiration timestamp set via <a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>. This callback is called only once when the scene expires even if scene stays expired in subsequent frames. When the scene is updated again with a new not anymore expired timestamp, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a> is called.  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1">More...</a><br /></td></tr>
<tr class="separator:abbc3814bfdaaf45fed51abdb3669dfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa78efc7b932172dd94a233bad9c4ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec">sceneRecoveredFromExpiration</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId) override</td></tr>
<tr class="memdesc:a9fa78efc7b932172dd94a233bad9c4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called if a scene which previously expired (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a> and <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>) was updated with a new expiration timestamp that is not expired anymore. This callback is called only once when the scene switches state from expired to not expired. This callback is not called when monitoring becomes disabled (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d" title="This method will be called whenever a scene which was previously monitored for expiration has request...">sceneExpirationMonitoringDisabled</a>) while scene is expired (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>).  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec">More...</a><br /></td></tr>
<tr class="separator:a9fa78efc7b932172dd94a233bad9c4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9edc11c14079f83e04fa51a9b1d8bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6f9edc11c14079f83e04fa51a9b1d8bf">streamAvailabilityChanged</a> (<a class="el" href="namespaceramses.html#ac79b962fa2712607b7497565e46f47ff">waylandIviSurfaceId_t</a> streamId, bool available) override</td></tr>
<tr class="memdesc:a6f9edc11c14079f83e04fa51a9b1d8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when a new IVI video stream becomes available, or when an existing stream disappears In terms of Wayland protocol, a stream is available if an "ivi_application" exists which has created a wayland surface (wl_surface) with ivi_id=streamId, and the surface has at least one attached non-nullptr buffer (i.e. renderable content).  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6f9edc11c14079f83e04fa51a9b1d8bf">More...</a><br /></td></tr>
<tr class="separator:a6f9edc11c14079f83e04fa51a9b1d8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdd89c1076420d99a0684ab306e7e73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6cdd89c1076420d99a0684ab306e7e73">objectsPicked</a> (<a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a> sceneId, const <a class="el" href="namespaceramses.html#a297993fd73b812e878accd5788e1b82c">pickableObjectId_t</a> *pickedObjects, uint32_t pickedObjectsCount) override</td></tr>
<tr class="memdesc:a6cdd89c1076420d99a0684ab306e7e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will be called when there were scene objects picked. A <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area.">ramses::PickableObject</a> can be 'picked' via a pick input event which is passed to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a> when the scene is rendered (see <a class="el" href="classramses_1_1RendererSceneControl.html#a6420e4d8b2754d6ac8831a3bda9233bb" title="Trigger renderer to test if given pick event with coordinates intersects with any instances of ramses...">ramses::RendererSceneControl::handlePickEvent</a>).  <a href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a6cdd89c1076420d99a0684ab306e7e73">More...</a><br /></td></tr>
<tr class="separator:a6cdd89c1076420d99a0684ab306e7e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classramses_1_1IRendererSceneControlEventHandler"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classramses_1_1IRendererSceneControlEventHandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html">ramses::IRendererSceneControlEventHandler</a></td></tr>
<tr class="memitem:a0dd8d4b47c9ee08733b2f184b4f591e4 inherit pub_methods_classramses_1_1IRendererSceneControlEventHandler"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a0dd8d4b47c9ee08733b2f184b4f591e4">~IRendererSceneControlEventHandler</a> ()=default</td></tr>
<tr class="memdesc:a0dd8d4b47c9ee08733b2f184b4f591e4 inherit pub_methods_classramses_1_1IRendererSceneControlEventHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty destructor.  <a href="classramses_1_1IRendererSceneControlEventHandler.html#a0dd8d4b47c9ee08733b2f184b4f591e4">More...</a><br /></td></tr>
<tr class="separator:a0dd8d4b47c9ee08733b2f184b4f591e4 inherit pub_methods_classramses_1_1IRendererSceneControlEventHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Convenience empty implementation of <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html" title="Provides an interface for handling the result of renderer scene control events. Implementation of thi...">IRendererSceneControlEventHandler</a> that can be used to derive from when only subset of event handling methods need to be implemented. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-datalink_2src_2main_8cpp-example.html#_a1">ramses-example-local-datalink/src/main.cpp</a>, <a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#_a2">ramses-example-local-offscreenbuffer/src/main.cpp</a>, <a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#_a8">ramses-example-local-pick-handling/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#_a2">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6db396b314db92c14266deee57164b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db396b314db92c14266deee57164b31">&#9670;&nbsp;</a></span>dataConsumerCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataConsumerCreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>dataConsumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a data consumer is created. </p>
<p>The event is emitted also for every data consumer in a newly available scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataConsumerId</td><td>The created data consumer id </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa729fd4d30eb716b0dc6a0d1a19cc168">ramses::IRendererSceneControlEventHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classSceneStateEventHandler.html#ac1e2477789a9dd0ef0a251daef82ed0c">SceneStateEventHandler</a>.</p>

</div>
</div>
<a id="abe9704414b9cfa42ba1be50f76aaaa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9704414b9cfa42ba1be50f76aaaa19">&#9670;&nbsp;</a></span>dataConsumerDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataConsumerDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>dataConsumerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a data consumer is destroyed. </p>
<p>The event is emitted only when data consumer destroyed, not if scene becomes unavailable as a whole. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataConsumerId</td><td>The destroyed data consumer id </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#abc6ee43f8171121da99a3d79573aca95">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a55b651548efc36f59d0276d673f3c38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b651548efc36f59d0276d673f3c38c">&#9670;&nbsp;</a></span>dataLinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataLinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>providerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>providerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between a data provider and data consumer is established. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#af4a77700e389a32581ad1b274552b010" title="Links a data provider from one scene to a data consumer in another scene.">ramses::RendererSceneControl::linkData</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">providerScene</td><td>The ID of scene where the data provider slot is </td></tr>
    <tr><td class="paramname">providerId</td><td>The ID of data provider which was linked </td></tr>
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer which was linked </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a4decbb725ad779954dbcdad427fd6206">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a81a9ba13148c9511965bc1df17d2574f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a9ba13148c9511965bc1df17d2574f">&#9670;&nbsp;</a></span>dataProviderCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataProviderCreated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>dataProviderId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a data provider is created. </p>
<p>The event is emitted also for every data provider in a newly available scene. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataProviderId</td><td>The created data provider id </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa4144b74fa03903c25022262f2c1c692">ramses::IRendererSceneControlEventHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classSceneStateEventHandler.html#ae7774e6f0c316722c9af4b959e03ea42">SceneStateEventHandler</a>.</p>

</div>
</div>
<a id="ace4eb3e937770dfe41c8726e25da5545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4eb3e937770dfe41c8726e25da5545">&#9670;&nbsp;</a></span>dataProviderDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataProviderDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab41878ab3cb9b206b58f32437faddd7f">dataProviderId_t</a>&#160;</td>
          <td class="paramname"><em>dataProviderId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a data provider is destroyed. </p>
<p>The event is emitted only when data provider destroyed, not if scene becomes unavailable as a whole. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
    <tr><td class="paramname">dataProviderId</td><td>The destroyed data provider id </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a7d9ea677b8a0f1126fc547d20f273ba5">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a2b50349138c5a3a21b34230cbc1906a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b50349138c5a3a21b34230cbc1906a2">&#9670;&nbsp;</a></span>dataUnlinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::dataUnlinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between a data provider and data consumer is destroyed. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a3705492a690fa9ec03ce9f5a50e74994" title="Removes an existing link between data provider and consumer (linkData) or offscreen buffer and consum...">ramses::RendererSceneControl::unlinkData</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer which was unlinked </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#afe4c204c021ddeee45297b7e63275e1b">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a6cdd89c1076420d99a0684ab306e7e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cdd89c1076420d99a0684ab306e7e73">&#9670;&nbsp;</a></span>objectsPicked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::objectsPicked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceramses.html#a297993fd73b812e878accd5788e1b82c">pickableObjectId_t</a> *&#160;</td>
          <td class="paramname"><em>pickedObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pickedObjectsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when there were scene objects picked. A <a class="el" href="classramses_1_1PickableObject.html" title="PickableObject provides a way to specify a &#39;pickable&#39; area.">ramses::PickableObject</a> can be 'picked' via a pick input event which is passed to <a class="el" href="classramses_1_1RendererSceneControl.html" title="Control states of scenes.">ramses::RendererSceneControl</a> when the scene is rendered (see <a class="el" href="classramses_1_1RendererSceneControl.html#a6420e4d8b2754d6ac8831a3bda9233bb" title="Trigger renderer to test if given pick event with coordinates intersects with any instances of ramses...">ramses::RendererSceneControl::handlePickEvent</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sceneId</td><td>ID of scene to which the picked objects belong. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pickedObjects</td><td>Pointer to first ID of the picked objects array. This array is valid only for the time of calling this method. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pickedObjectsCount</td><td>Number of picked object IDs in the <code>pickedObjects</code> array. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#acce04232c965e1f37fc0d366e69b7c8a">ramses::IRendererSceneControlEventHandler</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-pick-handling_2src_2main_8cpp-example.html#a17">ramses-example-local-pick-handling/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a53ade79e2fea4c8129ac9420e6fa7237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ade79e2fea4c8129ac9420e6fa7237">&#9670;&nbsp;</a></span>offscreenBufferLinked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::offscreenBufferLinked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af5114d3671e4be67752f61c301cd1581">displayBufferId_t</a>&#160;</td>
          <td class="paramname"><em>offscreenBufferId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>consumerScene</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#af0488b3b71ec902e1c07ab976043712b">dataConsumerId_t</a>&#160;</td>
          <td class="paramname"><em>consumerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>success</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when the data link between offscreen buffer and scene's data slot is established. </p>
<p>This is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a404275629b0b73ad04d10f4a1649e8ba" title="Links display&#39;s offscreen buffer to a data consumer in scene.">ramses::RendererSceneControl::linkOffscreenBuffer</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offscreenBufferId</td><td>The ID of offscreen buffer which is linked as data provider </td></tr>
    <tr><td class="paramname">consumerScene</td><td>The ID of scene where the data consumer slot is </td></tr>
    <tr><td class="paramname">consumerId</td><td>The ID of data consumer where the offscreen buffer is linked to </td></tr>
    <tr><td class="paramname">success</td><td>True if succeeded, false otherwise - check renderer logs for concrete error message. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#ac016d8f7c0e6ab084f6a8c86481b9288">ramses::IRendererSceneControlEventHandler</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a11">ramses-example-local-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9237861e7a2672972ce212f61e60c03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9237861e7a2672972ce212f61e60c03d">&#9670;&nbsp;</a></span>sceneExpirationMonitoringDisabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneExpirationMonitoringDisabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a scene which was previously monitored for expiration has requested to stop being monitored by sending a scene flush with invalid expiration timestamp (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>) and that flush was applied on renderer side. From this point on, the scene will not be monitored anymore, regardless if it previously expired or not, i.e. there will be no expiration events (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a>) until monitoring enabled again (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6" title="This method will be called whenever a scene which was not previously monitored for expiration has req...">sceneExpirationMonitoringEnabled</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene that will not be monitored for expiration anymore </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a2f9d3c748dc4a553bdcf32b3e7662e73">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="af8295cfd70d6a8a7b66652cdcbd654d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8295cfd70d6a8a7b66652cdcbd654d6">&#9670;&nbsp;</a></span>sceneExpirationMonitoringEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneExpirationMonitoringEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called whenever a scene which was not previously monitored for expiration has requested expiration monitoring by sending a scene flush with valid expiration timestamp (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>) and that flush was applied on renderer side. From this point on, the scene will be monitored, can expire and recover (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a>) until monitoring disabled again (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d" title="This method will be called whenever a scene which was previously monitored for expiration has request...">sceneExpirationMonitoringDisabled</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene that will be monitored for expiration </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#aa36f55ffddbe50085cb19020d9bc6886">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="abbc3814bfdaaf45fed51abdb3669dfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc3814bfdaaf45fed51abdb3669dfa1">&#9670;&nbsp;</a></span>sceneExpired()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneExpired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called if a scene which is enabled for expiration monitoring (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#af8295cfd70d6a8a7b66652cdcbd654d6" title="This method will be called whenever a scene which was not previously monitored for expiration has req...">sceneExpirationMonitoringEnabled</a>) is on renderer (not necessarily rendered) at a state that expired, i.e. current time is after the expiration timestamp set via <a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a>. This callback is called only once when the scene expires even if scene stays expired in subsequent frames. When the scene is updated again with a new not anymore expired timestamp, <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9fa78efc7b932172dd94a233bad9c4ec" title="This method will be called if a scene which previously expired (ramses::Scene::setExpirationTimestamp...">sceneRecoveredFromExpiration</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a994131648d8494923fd77c31a106c4c0">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a128450bdd7ef264424ef1f99036b6eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128450bdd7ef264424ef1f99036b6eb0">&#9670;&nbsp;</a></span>sceneFlushed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneFlushed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ab7aa6bed4d47d2bd0967fc1a5ed6e95b">sceneVersionTag_t</a>&#160;</td>
          <td class="paramname"><em>sceneVersionTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called after a flush with version tag (<a class="el" href="classramses_1_1Scene.html#ac12e7548df54a23bc10c1e5629c1aa88" title="Commits all changes done to the scene since the last flush or since scene creation....">ramses::Scene::flush</a>) has been applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene which the versioned flush belongs to </td></tr>
    <tr><td class="paramname">sceneVersionTag</td><td>The version tag of the scene flush </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a205d47bc91ef9d2cc60f39766bdf2bf8">ramses::IRendererSceneControlEventHandler</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a7">ramses-example-local-offscreenbuffer/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a9fa78efc7b932172dd94a233bad9c4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa78efc7b932172dd94a233bad9c4ec">&#9670;&nbsp;</a></span>sceneRecoveredFromExpiration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneRecoveredFromExpiration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called if a scene which previously expired (<a class="el" href="classramses_1_1Scene.html#a5a4e0fd8b04ce23881f3089bfc4c9556" title="Expiration timestamp is a point in time till which the scene is considered to be up-to-date....">ramses::Scene::setExpirationTimestamp</a> and <a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>) was updated with a new expiration timestamp that is not expired anymore. This callback is called only once when the scene switches state from expired to not expired. This callback is not called when monitoring becomes disabled (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#a9237861e7a2672972ce212f61e60c03d" title="This method will be called whenever a scene which was previously monitored for expiration has request...">sceneExpirationMonitoringDisabled</a>) while scene is expired (<a class="el" href="classramses_1_1RendererSceneControlEventHandlerEmpty.html#abbc3814bfdaaf45fed51abdb3669dfa1" title="This method will be called if a scene which is enabled for expiration monitoring (sceneExpirationMoni...">sceneExpired</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The scene id of the scene on which the event occurred </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a24f748b279d85ac3e0d0dc11740614a3">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<a id="a89bbf910ecb31b0ec8ee9b4298c426c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bbf910ecb31b0ec8ee9b4298c426c1">&#9670;&nbsp;</a></span>sceneStateChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::sceneStateChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a2e5eeeb38c74c74dea063659a1f02f33">sceneId_t</a>&#160;</td>
          <td class="paramname"><em>sceneId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#a7eda01f5f51a4235b9185fdaa007e82c">RendererSceneState</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when state of a scene changes. </p>
<p>Typically this is a result of <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene.">ramses::RendererSceneControl::setSceneState</a> call but can be also triggered externally (e.g. scene was unpublished by client). Note that there can be multiple state change callbacks in a row depending on number of state transitions needed between the previous state and target state when calling <a class="el" href="classramses_1_1RendererSceneControl.html#a3a67e00fdc6770676e44f1bc254604a0" title="Request state change of a scene.">ramses::RendererSceneControl::setSceneState</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sceneId</td><td>The ID of scene with changed state </td></tr>
    <tr><td class="paramname">state</td><td>New state of the scene </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a6d004040870b94940f0a67b843672f83">ramses::IRendererSceneControlEventHandler</a>.</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="ramses-example-local-offscreenbuffer_2src_2main_8cpp-example.html#a5">ramses-example-local-offscreenbuffer/src/main.cpp</a>, and <a class="el" href="ramses-example-local-viewport-link_2src_2main_8cpp-example.html#a5">ramses-example-local-viewport-link/src/main.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="a6f9edc11c14079f83e04fa51a9b1d8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9edc11c14079f83e04fa51a9b1d8bf">&#9670;&nbsp;</a></span>streamAvailabilityChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ramses::RendererSceneControlEventHandlerEmpty::streamAvailabilityChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceramses.html#ac79b962fa2712607b7497565e46f47ff">waylandIviSurfaceId_t</a>&#160;</td>
          <td class="paramname"><em>streamId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will be called when a new IVI video stream becomes available, or when an existing stream disappears In terms of Wayland protocol, a stream is available if an "ivi_application" exists which has created a wayland surface (wl_surface) with ivi_id=streamId, and the surface has at least one attached non-nullptr buffer (i.e. renderable content). </p>
<p>It is possible that the ivi_application does not update its surface (by providing new buffers/frames), but RAMSES has no way of knowing that, hence a stream is not reported unavailable in that case.</p>
<p>A surface becomes unavailable whenever either the ivi_application is closed or when it attached a nullptr buffer to the stream surface with id=streamId (i.e. actively told wayland that it should not render contents to this ivi surface).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">streamId</td><td>The IVI stream id </td></tr>
    <tr><td class="paramname">available</td><td>True if the stream became available, and false if it disappeared </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classramses_1_1IRendererSceneControlEventHandler.html#a0956f933dcda63a29aa301f024974c45">ramses::IRendererSceneControlEventHandler</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/q479079/sources/ramses-oss/renderer/RendererLib/ramses-renderer-api/include/ramses-renderer-api/<a class="el" href="IRendererSceneControlEventHandler_8h_source.html">IRendererSceneControlEventHandler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
